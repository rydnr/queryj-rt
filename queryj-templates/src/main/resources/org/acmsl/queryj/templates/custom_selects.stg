//;-*- mode: antlr -*-
//
//                      QueryJ
//
//  Copyright (C) 2002-today  ACM-SL
//                           chous@acm-sl.org
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//  Thanks to ACM S.L. for distributing this library under the GPL license.
//  Contact info: jose.sanleandro@acm-sl.com
//  Postal Address: c/Playa de Lagoa, 1
//                  Urb. Valdecabanas
//                  Boadilla del monte
//                  28660 Madrid
//                  Spain
//
//***************************************************************************
//
// Filename: custom_selects.stg
//
// Author: Jose San Leandro Armendariz
//
// Description: Defines the common templates dealing with custom selects.
//
group custom_selects;

import "javadoc.stg"
import "type_checkers.stg"

custom_select(cs, table, C) ::= <<
<!
 Writes the code for a custom select query.
 @param cs the custom select.
 @param table the table.
!>
<if(!cs.dynamic)>
/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:{ p | <parameter_javadoc(parameter=p)>}; separator="\n">
<if(cs.resultRef)>
 * @return the {@link <cs.resultClass>} information retrieved.
<else>
 * @return the {@link <cs.dao.voName>} information retrieved.
<endif>
 */
@Override
<custom_select_return_nullable_maybe(cs=cs, result=cs.result, C=C)>
public <custom_select_return(cs=cs, table=table, result=cs.result, C=C)> <cs.name.uncapitalized>(
    <if(!cs.parametersShouldBeWrapped)><cs.parameters:{ p | <attribute_method_parameter_declaration(attribute=p, usePrefix=false, prefix="", C=C)>}; separator=", ">)
<else>
    <cs.parameters:{ p | <attribute_method_parameter_declaration(attribute=p, usePrefix=false, prefix="", C=C)>}; separator=",\n">)<
endif>

    throws DataAccessException
{
    <notnull(C=C)>final String sql = auditSql(<cs.id.normalized.uppercased>_SQL);

    <notnull(C=C)>final PreparedStatementCreatorFactory preparedStatementCreatorFactory =
        new PreparedStatementCreatorFactory(sql);

    <cs.parameters:{ p | <custom_select_parameter_type_specification(
      type=p.sqlType)>}; separator="\n">

    return
        <cs.name.uncapitalized>(
            sql,
            preparedStatementCreatorFactory,
            new Object[<if(!cs.parameters)>0],
            <else>]
            {
                <cs.parameters:{ p | <custom_select_parameter_value(p=p)>}; separator=",\n">
            },
            <endif>
            createTransactionTemplate(getDataSource()),
            getDAOListener());
}

/**
 * Custom select \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 * @param sql the SQL.
 * @param preparedStatementCreatorFactory the
 * {@link PreparedStatementCreatorFactory} instance
 * specific for this operation.
 * @param params the query parameters.
 * @param transactionTemplate the {@link TransactionTemplate} instance.
 * @param daoListener the {@link DAOListener} instance.
<if(cs.resultRef)>
 * @return the {@link <cs.resultClass>} information retrieved.
<else>
 * @return the {@link <cs.dao.voName>} information retrieved.
<endif>
 */
<custom_select_return_nullable_maybe(cs=cs, result=cs.result, C=C)>
protected <custom_select_return(cs=cs, table=table, result=cs.result, C=C)> <cs.name.uncapitalized>(
    <notnull(C=C)>final String sql,
    <notnull(C=C)>final PreparedStatementCreatorFactory preparedStatementCreatorFactory,
    <nullable(C=C)>final Object[] params,
    <notnull(C=C)>final TransactionTemplate transactionTemplate,
    <nullable(C=C)>final DAOListener daoListener)
  throws DataAccessException
{
    <custom_select_result_declaration(sql=cs, result=cs.result, table=table, C=C)>

    /*
    preparedStatementCreatorFactory.setResultSetType(..);
    preparedStatementCreatorFactory.setUpdatableResults(..);
    preparedStatementCreatorFactory.setReturnGeneratedKeys(..);
    preparedStatementCreatorFactory.setGeneratedKeysColumnNames(..);
    */

    result =
        <custom_select_template_call(sql=cs, result=cs.result, table=table, C=C)>

    return result;
}
<endif>
>>

custom_select_parameter_type_specification(type) ::= <<
<!
  Specifies the type of the parameter of a custom select.
  @param type the SQL type.
!>
preparedStatementCreatorFactory.addParameter(new SqlParameter(Types.<type>));
>>

custom_select_parameter_value(p) ::= <<
<!
  Writes the value for a parameter of a custom select.
  @param p the parameter.
!>
<if(p.object)><p.name.uncapitalized><else><if(p.primitive)><p.objectType>.valueOf(<p.name.uncapitalized>)<else><if(p.string)><p.name.uncapitalized><else>new <p.objectType>(<p.name.uncapitalized>)<endif><endif><endif>
>>

custom_update_or_insert(cs, C) ::= <<
<!
 Writes the subtemplate for custom updates or inserts.
 @param cs the custom sql.
!>
<if(!cs.dynamic)>
/**
 * Custom sql \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:{ p | <parameter_javadoc(parameter=p)>}; separator="\n">
 * @return the number of entities updated.
 */
public int <cs.name.uncapitalized>(
    <cs.parameters:{ p | <attribute_method_parameter_declaration(attr=p, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
  throws DataAccessException
{
    int result = -10;

    final PreparedStatementCreatorFactory
        preparedStatementCreatorFactory =
            new PreparedStatementCreatorFactory(
                auditSql(<cs.idAsConstant>_SQL));

    /*
    t_PreparedStatementCreatorFactory.setResultSetType(..);
    t_PreparedStatementCreatorFactory.setUpdatableResults(..);
    t_PreparedStatementCreatorFactory.setReturnGeneratedKeys(..);
    t_PreparedStatementCreatorFactory.setGeneratedKeysColumnNames(..);
     */

    <cs.parameters:{ p | <custom_select_parameter_type_specification(
      type=p.sqlType)>}; separator="\n">

    <notnull(C=C)>final Object[] params =
       new Object[]
       {
           <cs.parameters:{ p | <custom_select_parameter_value(p=p)>}; separator=",\n">
        };

    <notnull(C=C)>final DataSourceTransactionManager transactionManager =
        new DataSourceTransactionManager(getDataSource());
    <notnull(C=C)>final TransactionTemplate transactionTemplate =
        new TransactionTemplate(transactionManager);

    <notnull(C=C)>final Object t_Result =
        transactionTemplate.execute(
            new UpdateTransactionCallback(
                preparedStatementCreatorFactory
                    .newPreparedStatementCreator(params),
                preparedStatementCreatorFactory
                    .newPreparedStatementSetter(params),
                this));


    if  (t_Result instanceof Integer)
    {
        result = ((Integer) t_Result).intValue();
    }

    /*
    result =
        update(
            t_PreparedStatementCreatorFactory
               .newPreparedStatementCreator(params),
            t_PreparedStatementCreatorFactory
               .newPreparedStatementSetter(params));
     */

    return result;
}
<endif>
>>

custom_select_for_update(cs, table, C) ::= <<
<!
 Writes the code for a custom select for update.
 @param cs the custom select.
 @param table the table.
!>
<if(!cs.dynamic)>
/**
 * Custom select for update \<i><cs.id>\</i>:\<br/>
 * \<b><cs.description>\</b>.
 <cs.parameters:{ p | <parameter_javadoc(parameter=p)>}; separator=",\n">
<if(cs.resultRef)>
 * @return the {@link <cs.resultClass>} information retrieved.
<else>
 * @return the {@link <cs.dao.voName>} information retrieved.
<endif>
 */
<if(cs.resultClass)>
<cs.result:{rs|<if(table.voDecorated)><if(rs.implicitProperties)>
public <cs.resultClass> <cs.name.uncapitalized>(
<else>
<if(cs.multiple)>
<notnull(C=C)>
public <cs.resultClass> <cs.name.uncapitalized>(
<else>
<nullable(C=C)>
public <cs.resultClass>Decorator <cs.name.uncapitalized>(
<endif>
<endif>
<else>
<nullable(C=C)>
public <cs.resultClass> <cs.name.uncapitalized>(
<endif>}>
<else>
public void <cs.name.uncapitalized>(
<endif>

    <cs.parameters:{ p | <attribute_method_parameter_declaration(attr=p, usePrefix=false, prefix="", C=C)>}; separator=",\n">)
  throws DataAccessException
{
<if(cs.resultClass)>
<cs.result:{rs|<if(table.voDecorated)><if(!rs.implicitProperties)><if(rs.multiple)>
    <nullable(C=C)><cs.resultClass> result = null;
<else>
    <nullable(C=C)><cs.resultClass>Decorator result = null;
<endif>
<endif>
<else>
    <nullable(C=C)><cs.resultClass> result = null;
<endif>}>
<else>
<endif>

    <notnull(C=C)>final SqlQuery t_Query =
        new SqlQuery(
            getDataSource(), <cs.normalized.uppercased>_SQL);

<if(cs.resultClass)>
    <nullable(C=C)>final List\<<cs.resultClass>\> t_lResult = (List\<<cs.resultClass>\>) t_Query.execute();

    if  (   (t_lResult != null)
         && (t_lResult.size() > 0))
    {
        result = t_lResult.get(0);
    }

    return result;
<else>
    t_Query.execute();
<endif>

}
<endif>
>>

custom_select_result_declaration(sql, result, table, C) ::= <<
<!
 Generates code to declare the custom-select result.
 @param sql the custom select.
 @param result the sql result.
 @param table the table.
 !>
<custom_select_return_nullable_maybe(cs=cs, result=cs.result, C=C)>final <custom_select_return(cs=sql, table=table, result=result, C=C)> result;
>>

implicit_custom_select_attribute_declaration(sql, attr) ::= <<
<!
 Generates the declaration of the property.
 @param sql the custom sql.
 @param attr the implicit property.
!>
<if(attr.nullable)>
<nullable(C=C)><sql.resultClass> result = null;
<else>
<attr.javaType> result = null;
<endif>

>>

custom_select_template_call(sql, result, table, C) ::= <<
<!
 Generates the call to execute the custom select.
 @param sql the custom select.
 @param result the sql result.
 @param table the table.
 !>
<custom_select_return_cast(cs=sql, table=table, result=result, C=C)>
    <actual_custom_select_template_call(sql=sql, result=result, C=C)>;
>>

actual_custom_select_template_call(sql, result, C) ::= <<
<!
 Generates the actual call to the template for the custom select.
 @param sql the custom select.
 @param result the sql result.
 !>
transactionTemplate.execute(
    new QueryTransactionCallback(
        preparedStatementCreatorFactory
            .newPreparedStatementCreator(params),
        null,
        // calls setXXX twice
        // preparedStatementCreatorFactory
        //     .newPreparedStatementSetter(params),
<if(sql.resultRef)>
        new <sql.result.id.voName>Extractor(sql, daoListener),
<else>
        new <sql.dao.voName>Extractor(sql, daoListener),
<endif>
        this))
>>

custom_select_return(cs, table, result, C) ::= <<
<
if(table.voDecorated)><
  custom_select_return_decorated(cs=cs, result=result, C=C)><
else><
  custom_select_return_nondecorated(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_decorated(cs, result, C) ::= <<
<
if(cs.resultRef)><
  custom_select_return_decorated_explicit(cs=cs, result=result, C=C)><
else><
  custom_select_return_decorated_implicit(cs=cs, result=result, C=C)><
endif>
>>

custom_select_decorated_explicit(cs, result, C) ::= <<
<
if(cs.multiple)><
  custom_select_return_decorated_explicit_multiple(cs=cs, result=result, C=C)><
else><
  custom_select_return_decorated_explicit_single(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_decorated_explicit_multiple(cs, result, C) ::= <<
List\<<result.classValue>Decorator\>
>>

custom_select_return_decorated_explicit_single(cs, result, C) ::= <<
<result.classValue>Decorator
>>

custom_select_return_nondecorated(cs, result, C) ::= <<
<
if(cs.resultRef)><
  custom_select_return_nondecorated_explicit(cs=cs, result=result, C=C)><
else><
  custom_select_return_nondecorated_implicit(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_nondecorated_explicit(cs, result, C) ::= <<
<
if(cs.multiple)><
  custom_select_return_nondecorated_explicit_multiple(cs=cs, result=result, C=C)><
else><
  custom_select_return_nondecorated_explicit_single(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_nondecorated_explicit_multiple(cs, result, C) ::= <<
<
if(result.wrappingASingleProperty)><
  custom_select_return_explicit_property_multiple(cs=cs, result=result, C=C)><
else
 >List\<<result.classValue>\><
endif>
>>

custom_select_return_nondecorated_explicit_single(cs, result, C) ::= <<
<
if(result.wrappingASingleProperty)><
  custom_select_return_explicit_property_single(cs=cs, result=result, C=C)><
else><
  result.classValue><
endif>
>>

custom_select_return_explicit_property_multiple(cs, result, C) ::= <<
List\<<result.properties:{property|<property.objectType>}>\>
>>

custom_select_return_explicit_property_single(select, result, C) ::= <<
<result.properties:{property|<if(!property.primitive)><endif><property.type>}>
>>

custom_select_return_decorated_implicit(cs, result, C) ::= <<
<
if(cs.multiple)><
  custom_select_return_decorated_implicit_multiple(cs=cs, result=result, C=C)><
else><
  custom_select_return_decorated_implicit_single(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_decorated_implicit_multiple(cs, result, C) ::= <<
List\<<cs.dao.voName>Decorator>
>>

custom_select_return_decorated_implicit_single(cs, result, C) ::= <<
<cs.dao.voName>Decorator
>>

custom_select_return_nondecorated_implicit(cs, result, C) ::= <<
<
if(cs.multiple)><
  custom_select_return_nondecorated_implicit_multiple(cs=cs, result=result, C=C)><
else><
  custom_select_return_nondecorated_implicit_single(cs=cs, result=result, C=C)><
endif>
>>

custom_select_return_nondecorated_implicit_multiple(cs, result, C) ::= <<
List\<<cs.dao.voName>\>/**/
>>

custom_select_return_nondecorated_implicit_single(cs, result, C) ::= <<
<cs.dao.voName>
>>

custom_select_return_import(result, package, C) ::= <<
<if(result.wrappingASingleProperty)><
  custom_select_return_import_property_single(result=result, package=package)><
else><
  if(result.classValue)
>import <result.classValue>;
<endif><endif>
>>

custom_select_return_import_property_single(result, package) ::= <<
<!<result.properties:{property|<if(!property.primitive)>import <property.type>;<endif>}>!>
>>

custom_select_return_cast(cs, table, result, C) ::= <<
(<custom_select_return(cs=cs, table=table, result=result, C=C)>)
>>

custom_select_return_nullable_maybe(cs, result, C) ::= <<
<if(cs.multiple)><notnull(C=C)><else><if(cs.resultRef)><if(result.wrappingASingleProperty)><result.properties:{property|<if(property.object)><nullable(C=C)><endif>}><else><nullable(C=C)><endif><else><nullable(C=C)><endif><endif>
>>
